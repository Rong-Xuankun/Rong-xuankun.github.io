# 数据结构



## 绪论

### 什么是数据结构

* 数据结构

  > 数据、数据项、数据对象、数据结构（逻辑结构、存储结构、数据的运算）

* 逻辑结构

  > **数据的逻辑结构是从数据元素的逻辑关系上描述数据的，是指数据元素之间的逻辑关系的整体，通常是从求解问题中提炼出来的**
  >
  > 集合、线性结构、树形结构

* 存储结构

  > 顺序存储结构
  >
  > 链式存储结构
  >
  > 索引存储结构
  >
  > 哈希存储结构

* 数据运算

  > 检索、插入、删除、更新、排序等

* 数据类型和抽象数据类型

  > 数据类型：变量、指针、数组、结构体、共用体
  >
  > 静态存储空间分配：`int a[10]`
  >
  > 动态存储空间分配：`(char *)malloc(sizeof(char))`



### 算法及其描述

* 算法的特性

  > 有穷性、确定性、可行性、有输入、有输出



### 算法分析

* 算法时间性能分析

  > 时间复杂度：T(n)用“O”表示
  >
  > 大O是Order的缩写，其含义是为T(n)找到了一个上界f(n)，其严格的数学定义是T(n)的数量级表示为O(f(n))

  **算法时间复杂度也称为渐进时间复杂度，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同**

  > O(1) < O(log2n) < O(n) < O(nlog2n) < O(n2) < O(2n) < O(n!)

  求和定理：取最大值（多个并列循环）

  求积定理：直接相乘（多层嵌套循环）

  > 最好、最坏时间复杂度：考虑一种或几种特殊的情况
  >
  > 平均时间复杂度：需要考虑所有情况

  > 递归时间复杂度：写出对应的递推试

* 算法空间性能分析

  > 空间复杂度：S(n)

  算法空间复杂度是对一个算法在运行过程中临时占有的存储空间大小的度量

  > 递归算法空间复杂度分析：为了实现递归算法过程用到一个递归栈，所以需要根据递归深度得到算法的空间复杂度



**什么是算法的时间复杂度？如何计算算法的时间复杂度？大O表示法的真实含义是什么？**

​	算法时间复杂度也称为渐进时间复杂度，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同；大O是Order的缩写，其含义是为T(n)找到了一个上界f(n)，其严格的数学定义是T(n)的数量级表示为O(f(n))。

**什么是逻辑结构？什么是数据元素？什么是数据项？什么是数据类型？它们有什么联系？**

​	数据的***逻辑结构***是从数据元素的逻辑关系上描述数据的，是指数据元素之间的逻辑关系的整体，通常是从求解问题中提炼出来的；***数据元素***是数据的基本单位，可以由若干个数据项组成；***数据项***是具有独立含义的数据最小单位；



-----



## 线性表

**什么是线性表？它的最主要的性质是什么？**

​	***线性表***是具有相同特性的数据元素的一个有限序列；它的性质：***有穷性、一致性、序列性***。

**什么是顺序存储结构？什么是链式存储结构？可以在数组中存放链表吗？如何存放？在数组中存放链表时，那些删除完成后留出的空位如何管理？**

**什么是单链表？什么是双向链表？什么是循环链表？什么是静态链表？静态链表中结点里包含的指针实际上代表什么？**



### 线性表的顺序存储结构

#### 顺序表：

```c
typedef int ElemType;
typedef struct
{
    ElemType data[MaxSize]; //存放线性表中的元素
    int length;             //存放线性表的长度
} SqList;                   //顺序表类型
```

* 建立顺序表
* 初始化线性表
* 销毁线性表
* 判断线性表是否为空表
* 求线性表的长度
* 输出线性表
* 求线性表中的某个数据元素值
* 按元素值查找
* 插入数据元素
* 删除数据元素

### 线性表的链式存储结构

#### 单链表

#### 双链表



-----



## 图

用邻接表存图有两个优点。

1. 节省空间：当图的顶点数很多、但是边的数量很少时，如果用邻接矩阵，我们就需要开一个很大的二维数组，最后我们需要存储 n^2*n*2 个数。但是用邻接表，最后我们存储的数据量只是边数的两倍。
2. 可以记录重复边：如果两个点之间有多条边，用邻接矩阵只能记录一条，但是用邻接表就能记录多条。虽然重复的边看起来是多余的，但在很多时候对解题来说是必要的。

当然，有优点就有缺点，用邻接表存图的最大缺点就是随机访问效率低。比如，我们需要询问点 a 是否和点 b 相连，我们就要遍历链表，检查里面是否有 b。而在邻接矩阵中，只需要根据`G[a][b]`就能判断。

因此，我们需要对不同的应用情景选择不同的存图方法。如果是稀疏图（顶点很多、边很少），一般用邻接表；如果是稠密图（顶点很少、边很多），一般用邻接矩阵。

### Dijkstra算法

使用前提(缺点)：边权非负

-----



## 内排序

### 1.插入排序

* 直接插入排序：

  > 总的比较和移动元素次数约为O(n2)
  >
  > 时间复杂度为O(n2),空间复杂度为O(1)
  >
  > 是***稳定***的排序方法

* 折半插入排序（二分插入排序）：

  >移动次数与直接插入排序相同，但是减少了关键字的比较次数
  >
  >查找速度优于直接插入排序,空间复杂度为O(1)
  >
  >是***稳定***的排序方法

* 希尔排序：

  实际上是一种分组插入方法。

  > 一般认为其平均时间复杂度为O(n1.3),速度通常比直接插入排序快
  >
  > 空间复杂度为O(1)
  >
  > 是***不稳定***的排序方法



### 2.交换排序

* 冒泡排序：

  ```c
  for(i = 0; i < n - 1; i++)
    for(j = 0; j < n - i - 1; j++)
    {
      if(R[i].key > R[i+1].key)
      {
     	 	tmp = A[j];
      	A[j] = A[j+1];
      	A[j+1] = tmp;
      }
    }
  ```

  改进的冒泡算法：判断一趟中是否交换了顺序，若交换了直接结束算法。

  ```c
  void BubbleSort1(RecType R[], int n)
  {
    int i, j;
    bool exchange;
    for(i = 0; i < n - 1; i++)
    {
      exchange = false;
      for(j = 0; j < n - i - 1; j++)
      {
        if (R[j].key < R[j+1].key)
        {
          swap(R[j], R[j+1]);
          exchange = false;
        }
      }
      if (!exchange)
        return;
    }
  }
  ```

  > 平均时间复杂度为O(n2)
  >
  > 空间复杂度为O(1)
  >
  > 是***稳定***的排序方法

* 快速排序：

  ***递归算法：***

  ```c
  int partition(RecType R[], int s, int t)
  {
      int i = s, j = t;
      RecType tmp = R[i];
      while (i < j)
      {
          while (j > i && R[j].key >= tmp.key)
              j--;
          R[i] = R[j];
          while (i < j && R[i].key <= tmp.key)
              i++;
          R[j] = R[i];
      }
      R[i] = tmp;
      return i;
  }
  void QuickSort(RecType R[], int s, int t)
  {
      int i;
      if (s < t)
      {
          i = partition(R, s, t);
          QuickSort(R, s, i - 1);
          QuickSort(R, i + 1, t);
      }
  }
  ```

  ***非递归算法：***

  （补充）

  > 时间复杂度：O(nlog2n)
  >
  > 空间复杂度：O(log2n)
  >
  > 是***不稳定***的一种排序



### 3.选择排序

* 简单选择排序：

  从当前无序区中选出关键字最小的元素R[k]，将它与无序区的第一个元素R[i]交换

  ```c
  void Select(RecType R[], int n)
  {
      int i, j, k;
      for (i = 0; i < n - 1; i++)
      {
          k = i;
          for (j = i + 1; j < n; j++)
              if (R[j].key < R[k].key)
                  k = j;
          if (k != i)
              swap(R[i], R[k]);
      }
  }
  ```

  > 平均时间复杂度：O(n2)
  >
  > 空间复杂度：O(1)
  >
  > 是***不稳定***的一种排序

* 堆排序：

  ```c
  void sift(RecType R[], int low, int high)
  {
      int i = low, j = 2 * i;
      RecType tmp = R[i];
      while (j <= high)
      {
          if (j < high && R[j].key < R[j + 1].key)
              j++;
          if (tmp.key < R[j].key)
          {
              R[i] = R[j];
              i = j;
              j = 2 * i;
          }
          else
              break;
      }
      R[i] = tmp;
  }
  void HeapSort(RecType R[], int n)
  {
      int i;
      for (i = n / 2; i >= 1; i--)
          sift(R, i, n);
      for (i = n; i >= 2; i--)
      {
          swap(R[1], R[i]);
          sift(R, 1, i - 1);
      }
  }
  ```

  > 时间复杂度为O(nlog2n)
  >
  > 空间复杂度为O(1)
  >
  > 是***不稳定***的一种排序



### 4.归并排序

* 二路归并算法：

  每次从两个段中取出一个元素进行关键字的比较，将较小者放入R1中，最后将各段中余下的部分直接复制到R1中，这样R1是一个有序表，再将其复制到R中

  > 时间复杂度为O(nlog2n)
  >
  > 空间复杂度为O(n)
  >
  > 是***稳定***的一种算法



### 5.基数排序

* 通过“分配”和“收集”过程来实现排序，不需要进行关键字间的比较，是一种借助于多关键字排序的思想对单关键字排序的方法
* 最低位优先和最高位优先



### 6.各种内排序方法的比较和选择

* 平方阶O(n2)排序：一般成为简单排序方法，例如直接插入排序、简单选择排序和冒泡排序

* 线性对数阶O(nlog2n)排序：如快速排序、堆排序和归并排序

* 线性阶O(n)排序：如基数排序（假定数据的位数d和进制r为常量时）

  > 没有哪一种排序方法是绝对好的。每一种排序方法都有其优缺点，适合于不同的环境
  >
  > 首先考虑排序对稳定性的要求，若要求稳定，则智能在稳定方法中选取，否则可以在所有方法中选取；其次要考虑带排序个数n的大小，若n较大，则可以在改进方法中选取，否则在简单方法中选取；然后再考虑其他因素。
  >
  > * 若n较小（如n<50），可采用直接插入或简单选择排序。一般地，这两种排序方法中，直接插入排序比较好，但简单选择排序四栋的元素数少于直接插入排序。
  > * 若文件初始状态基本有序（指正序），则选用直接插入或冒泡排序为宜。
  > * 若n较大，应采用时间复杂度为线性对数阶的排序方法，例如快速排序、堆排序或二路归并排序。快速排序是目前基于比较的内排序中被认为是较好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最少；但堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏的情况。这两种排序都是不稳定的，若要求排序稳定，则可以选择二路归并排序。
  > * 若需要将两个有序表合并成一个新的有序表，最好用二路归并排序方法。
  > * 基数排序可能在O(n)时间内完成对n个元素的排序。但遗憾的是，基数排序只适用于像字符串和整数这类有明显结构特征的关键字，而当关键字的取值范围属于某个无穷集合（例如实数型关键字）时无法使用基数排序，这是只有借助于“比较”的方法来排序。由此可知，若n很大，元素的关键字位数较少且可以分解时采用基数排序较好。
